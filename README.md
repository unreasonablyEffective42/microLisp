MicroLisp is a lightweight lisp interpreter loosely based on the syntax and semantics of the Scheme programming language.

This is an honors project for my Java programming class at CCD.

This interpreter currently supports BigInt arithmetic, string literals, lists, functions and recursion.

The syntax and semantics almost entirely follow from Scheme. Some differences include: 
- "Purely" functional. There are no mutations. IO is impure.
- `car` and `cdr` are replaced with `head` and `tail` 
- `(define (fnName arg1 arg2 ...) functionBody)` is instead <br/> `(define fnName (lambda (arg1 arg2 ...) functionBody))`
-   Lambdas of no arguments are not allowed.
-   All special forms `lambda, cond, let, lets` bodies are a single expression instead of allowing multiple expressions. i.e `(lambda (x) (print x) (+ x 1))` does not `print x` and then `return x +1`. It just ignores the second expression. Use `(do expr1 expr2 ... exprn)` to sequentially evaluate expressions, which will discard all their values except for the final expression. To keep and then use sequential values, chain functions or use `lets`
- Currently there is only `'` and `quote`, no quasiquoting `` ` `` , unquoting`,`, unquotesplicing `,@` etc 
- Tail recursion is not yet implemented, and with the only looping construct being recursion, this interpreter is limited.


To build, clone the repository  
`git clone [https://github.com/unreasonablyeffective42/microlisp` 
and from the directory ./MicroLisp, enter: `./BUILD` 
Then you can run from a new terminal with `microlisp -ip` Optionally you can pass it a file to load as well `microlisp -flags file.scm`

To build it yourself, navigate to the MicroLisp directory then `javac -d ./out ./src/*.java` To run just `java -cp ./out/ MicroLisp` + optional files to be loaded.

After building try:
`microlisp ./examples/lists.scm ./examples/examples.scm ./examples/primetest.scm`
`microlisp ./examples/lists.scm ./examples/gol.scm`

The flags to pass are: 
- i: interactive mode(repl).
- p: context aware repl(will indent next lines appropriately during multiline input, does not work with copy/paste multiline inputs).
- l: debug level low, displays the AST generated by the parser for the inputted expression.
- h: debug level high, displays low level debug info, and the raw token stream from the lexer.
